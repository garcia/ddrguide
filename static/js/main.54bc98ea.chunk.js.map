{"version":3,"sources":["Term.tsx","Glossary.tsx","SearchBar.tsx","App.tsx","serviceWorker.js","index.js","Autosuggest.module.scss"],"names":["Term","s","toLowerCase","replace","output","index","length","nextNewline","indexOf","nextLink","push","slice","linkEnd","console","error","linkData","linkDivider","linkDisplay","linkTerm","anchor","startsWith","this","makeTermAnchor","source","join","renderers","link","routerLinkRenderer","title","aka","trivia","props","term","definition","className","formatText","undefined","acronym","id","href","match","children","to","React","Component","GlossaryStore","allTerms","termLookup","instance","AssertionError","glossaryJson","forEach","entry","Glossary","store","getInstance","sortedTerms","sort","a","b","localeCompare","termElements","map","t","Suggestion","displayText","matchedTerm","termProps","boldRegion","boldL","boldR","input","glossaryStore","suggestions","suggested","SearchBar","state","value","onSuggestionsFetchRequested","bind","onSuggestionsClearRequested","onChange","setState","getSuggestions","event","params","newValue","inputProps","placeholder","getSuggestionValue","renderSuggestion","theme","Autosuggest_theme","Index","Sidebar","createBrowserHistory","basename","process","App","Helmet","defaultTitle","titleTemplate","charSet","rel","path","exact","component","Boolean","window","location","hostname","rootElement","document","getElementById","hasChildNodes","hydrate","render","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.54bc98ea.chunk.js","sourcesContent":["import React from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport { HashLink } from 'react-router-hash-link';\n\nimport './Term.scss';\n\nexport interface TermProps {\n    term: string;\n    acronym?: string;\n    aka?: string[];\n    definition: string;\n    trivia?: string;\n    help?: string;\n}\n\nclass Term extends React.Component<TermProps> {\n\n    static routerLinkRenderer(props: {href: string, children: JSX.Element}): JSX.Element {\n        return (\n          props.href.match(/^(https?:)?\\/\\//)\n            ? <a href={props.href}>{props.children}</a>\n            : <HashLink to={props.href}>{props.children}</HashLink>\n        );\n      }      \n\n    makeTermAnchor(s: string): string {\n        return \"term-\" + s.toLowerCase().replace(\" \", \"-\");\n    }\n\n    formatText(s: string): JSX.Element {\n        // Pre-format for Markdown\n        let output: string[] = [];\n        let index: number = 0;\n\n        while (index < s.length) {\n            \n            // Find next occurrence of either a newline or a link marker\n            let nextNewline = s.indexOf(\"\\n\", index);\n            let nextLink = s.indexOf(\"[\", index);\n\n            if (nextNewline >= 0 && (nextLink < 0 || nextNewline < nextLink)) {\n                \n                // Newline is next - push text fragment, then two newlines to start a new Markdown paragraph\n                output.push(s.slice(index, nextNewline));\n                output.push(\"\\n\");\n                index = nextNewline + 1;\n\n            } else if (nextLink >= 0 && (nextNewline < 0 || nextLink < nextNewline)) {\n                \n                // Link marker is next - push text fragment, then parse the link\n                output.push(s.slice(index, nextLink));\n\n                // Find next closing bracket\n                let linkEnd: number = s.indexOf(\"]\", nextLink);\n                if (linkEnd < 0) {\n                    console.error(\"Missing closing bracket for link at index \" + index + \" in string: \" + s);\n                    break;\n                }\n\n                // Check for dividing \"|\" - if present, the left part is the text to display and the right part is the term to link\n                let linkData: string = s.slice(nextLink+1, linkEnd);\n                let linkDivider: number = linkData.indexOf(\"|\");\n                let linkDisplay: string;\n                let linkTerm: string;\n                if (linkDivider >= 0) {\n                    linkDisplay = linkData.slice(0, linkDivider);\n                    linkTerm = linkData.slice(linkDivider+1);\n                } else {\n                    linkDisplay = linkTerm = linkData;\n                }\n\n                let anchor: string = linkTerm.startsWith(\"http\") ? linkTerm : \"#\" + this.makeTermAnchor(linkTerm);\n\n                // Push the resulting link\n                output.push(\"[\" + linkDisplay + \"](\" + anchor + \")\");\n                index = linkEnd + 1;\n\n            } else {\n\n                // No more newlines or links to parse - push remaining text\n                output.push(s.slice(index));\n                index = s.length;\n\n            }\n        }\n\n        return <ReactMarkdown\n                source={output.join(\"\")}\n                renderers={{link: Term.routerLinkRenderer}}\n            />;\n    }\n\n    render() {\n        let anchor: string = this.makeTermAnchor(this.props.term);\n        let title: JSX.Element;\n        let aka: JSX.Element | undefined;\n        let definition: JSX.Element = <div className=\"definition\">{this.formatText(this.props.definition)}</div>;\n        let trivia: JSX.Element | undefined;\n\n        if (this.props.acronym !== undefined) {\n            title = <h2>{this.props.term} ({this.props.acronym})</h2>\n        } else {\n            title = <h2>{this.props.term}</h2>\n        }\n\n        if (this.props.aka !== undefined) {\n            aka = <div className=\"aka\"><p>Also known as: {this.props.aka.join(\", \")}</p></div>;\n        }\n\n        if (this.props.trivia !== undefined) {\n            trivia = (\n                <div className=\"trivia\">\n                    <h3>Trivia</h3>\n                    {this.formatText(this.props.trivia)}\n                </div>\n            );\n        }\n        \n        return (\n            <div id={anchor} className=\"Term\">\n                {title}\n                {aka}\n                {definition}\n                {trivia}\n            </div>\n        );\n    }\n}\n\nexport default Term;","import React from 'react';\nimport Term, { TermProps } from './Term';\nimport glossaryJson from './glossary.json';\nimport { AssertionError } from 'assert';\nimport Helmet from 'react-helmet';\n\nimport './Glossary.scss';\nimport { HashLink } from 'react-router-hash-link';\n\nexport class GlossaryStore {\n    \n    static instance?: GlossaryStore;\n\n    allTerms: TermProps[] = [];\n    termLookup: {[key: string]: TermProps} = {};\n\n    constructor() {\n        if (GlossaryStore.instance !== undefined) {\n            throw new AssertionError();\n        }\n        glossaryJson.forEach(entry => {\n            this.termLookup[entry.term] = entry;\n            this.allTerms.push(entry);\n        })\n    }\n\n    static getInstance(): GlossaryStore {\n        if (GlossaryStore.instance === undefined) {\n            GlossaryStore.instance = new GlossaryStore();\n        }\n        return GlossaryStore.instance;\n    }\n}\n\nclass Glossary extends React.Component {\n    store: GlossaryStore = GlossaryStore.getInstance();\n\n    render() {\n        let sortedTerms: TermProps[] = this.store.allTerms.slice();\n        sortedTerms.sort((a, b) => a.term.localeCompare(b.term));\n        let termElements: JSX.Element[] = sortedTerms.map(t => <Term {...t} />);\n        return (\n            <div className=\"glossary\">\n                <Helmet>\n                    <title>Glossary</title>\n                </Helmet>\n                <div className=\"contentHeader\">\n                    <h1>Glossary</h1>\n                    <p>\n                        A comprehensive glossary of DanceDanceRevolution terminology.\n                        Please note that these definitions are focused on <HashLink to=\"#term-dancedancerevolution-a\">DDR A</HashLink> and <HashLink to=\"#term-dancedancerevolution-a20\">DDR A20</HashLink>,\n                        the two most recent DDR mixes at the time of writing, and\n                        the primary focus of the Western competitive scene.\n                    </p>\n                </div>\n                {termElements}\n            </div>\n        )\n    }\n}\n\nexport default Glossary;","import React, { ChangeEvent } from 'react';\nimport Autosuggest, { SuggestionsFetchRequestedParams } from 'react-autosuggest';\nimport { TermProps } from './Term';\nimport { GlossaryStore } from './Glossary';\nimport Autosuggest_theme from './Autosuggest.module.scss';\n\ninterface SearchBarProps {\n}\n\ninterface SearchBarState {\n    value: string;\n    suggestions: SuggestionProps[];\n}\n\ninterface SuggestionProps {\n    termProps: TermProps;\n    matchedTerm: string;\n    boldRegion: [number, number];\n}\n\nclass Suggestion extends React.Component<SuggestionProps> {\n\n    static getSuggestions(input: string): SuggestionProps[] {\n        const glossaryStore: GlossaryStore = GlossaryStore.getInstance();\n\n        if (input.length === 0) {\n            return [];\n        }\n        input = input.toLowerCase();\n\n        let suggestions: SuggestionProps[] = [];\n        let suggested: {[key: string]: boolean | undefined} = {};\n        \n        for (let termProps of glossaryStore.allTerms) {\n            if (suggested[termProps.term] === undefined && termProps.term.toLowerCase().startsWith(input)) {\n                suggestions.push({\n                    termProps: termProps,\n                    matchedTerm: termProps.term,\n                    boldRegion: [0, input.length]\n                });\n                suggested[termProps.term] = true;\n            }\n        }\n\n        for (let termProps of glossaryStore.allTerms) {\n            if (suggested[termProps.term] === undefined && termProps.aka !== undefined) {\n                for (let aka of termProps.aka) {\n                    if (aka.toLowerCase().startsWith(input)) {\n                        suggestions.push({\n                            termProps: termProps,\n                            matchedTerm: aka,\n                            boldRegion: [0, input.length]\n                        });\n                        suggested[termProps.term] = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return suggestions;\n    }\n\n    render() {\n        let displayText: string;\n        if (this.props.matchedTerm === this.props.termProps.term) {\n            displayText = this.props.matchedTerm;\n        } else {\n            displayText = this.props.matchedTerm + ' (' + this.props.termProps.term + ')';\n        }\n        var [boldL, boldR] = this.props.boldRegion;\n        return (\n            <>\n                {displayText.slice(0, boldL)}\n                <b>{displayText.slice(boldL, boldR)}</b>\n                {displayText.slice(boldR)}\n            </>\n        );\n    }\n}\n\nclass SearchBar extends React.Component<SearchBarProps> {\n    \n    glossaryStore: GlossaryStore = GlossaryStore.getInstance();\n    state: SearchBarState;\n    \n    constructor(props: SearchBarProps) {\n        super(props);\n        \n        this.state = {\n            value: '',\n            suggestions: []\n        };\n\n        this.onSuggestionsFetchRequested = this.onSuggestionsFetchRequested.bind(this);\n        this.onSuggestionsClearRequested = this.onSuggestionsClearRequested.bind(this);\n        this.onChange = this.onChange.bind(this);\n    }\n\n    onSuggestionsFetchRequested(value: SuggestionsFetchRequestedParams): void {\n        this.setState({\n            suggestions: Suggestion.getSuggestions(value.value)\n        });      \n    }\n\n    onSuggestionsClearRequested(): void {\n        this.setState({\n            suggestions: []\n        });      \n    }\n    \n    onChange(event: ChangeEvent<HTMLInputElement>, params: Autosuggest.ChangeEvent): void {\n        this.setState({\n            value: params.newValue\n        });\n    };\n\n    render() {\n        const inputProps = {\n            placeholder: 'Search',\n            value: this.state.value,\n            onChange: this.onChange\n        };\n\n        return (\n            <Autosuggest\n                suggestions={this.state.suggestions}\n                onSuggestionsFetchRequested={this.onSuggestionsFetchRequested}\n                onSuggestionsClearRequested={this.onSuggestionsClearRequested}\n                getSuggestionValue={(props) => props.termProps.term}\n                renderSuggestion={(props) => <Suggestion {...props} />}\n                inputProps={inputProps}\n                theme={Autosuggest_theme}\n            />\n        )\n    }\n}\n\nexport default SearchBar;","import React from 'react';\nimport { Helmet } from 'react-helmet';\nimport { BrowserRouter as Router, Route, Link } from 'react-router-dom';\nimport { createBrowserHistory } from 'history';\n\nimport './App.scss';\nimport Glossary from './Glossary';\nimport SearchBar from './SearchBar';\n\nfunction Index() {\n    return (\n        <SearchBar />\n    );\n}\n\nfunction Sidebar() {\n    return (\n        <nav className=\"column\">\n            <div className=\"columnHeader\">\n                DDRGuide\n            </div>\n            <div className=\"columnContents\">\n                <ul>\n                    <li>\n                        <Link to=\"/\">Home</Link>\n                    </li>\n                    <li>\n                        <Link to=\"/glossary/\">Glossary</Link>\n                    </li>\n                </ul>\n            </div>\n        </nav>\n    )\n}\n\nfunction App() {\n    return (\n        <Router basename={process.env.PUBLIC_URL}>\n            <Helmet defaultTitle=\"DDRGuide\" titleTemplate=\"%s | DDRGuide\">\n                <meta charSet=\"utf-8\" />\n                <link rel=\"canonical\" href=\"https://garcia.github.io/ddrguide\" />\n            </Helmet>\n            <div className=\"App\">\n                <Sidebar />\n                <article className=\"column\">\n                    <div className=\"columnContents\">\n                        <Route path=\"/\" exact component={Index} />\n                        <Route path=\"/glossary/\" component={Glossary} />\n                    </div>\n                </article>\n            </div>\n        </Router>\n    );\n}\n\nexport const history = createBrowserHistory({\n    basename: process.env.PUBLIC_URL\n});\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport { hydrate, render } from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nconst rootElement = document.getElementById(\"root\");\nif (rootElement.hasChildNodes()) {\n  hydrate(<App />, rootElement);\n} else {\n  render(<App />, rootElement);\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Autosuggest_container__26yBe\",\"suggestionsList\":\"Autosuggest_suggestionsList__1OlYf\",\"suggestion\":\"Autosuggest_suggestion__w5_sr\",\"suggestionHighlighted\":\"Autosuggest_suggestionHighlighted__jkCBD\"};"],"sourceRoot":""}